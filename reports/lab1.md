# Laboratory work nr.1

### Course: Formal Languages & Finite Automata
### Author: Maxim Cojocari-Goncear

----

## Theory
A grammar $G$ is an ordered quadruple $G = (V_N, V_T, P, S)$
where:

- $V_N$ is a finite set of non-terminal symbols;
- $V_T$ is a finite set of terminal symbols, $V_N \cap V_T = \varnothing$ ;
- $S \in N$ is a start symbol;
- $P$ is a finite set of productions of rules
 
The language generated by the grammar $G$ is denoted by $L(G)$ and represents the set of all strings of terminals that are derivable from the start symbol $S$.

A deterministic finite automaton is a 5-tuple $(Q, \Sigma, \delta, q_0, F)$ where:

- $Q$ is a finite set of states;
- $\Sigma$ is an input alphabet;
- $\delta: Q \times \to \Sigma $ is a transition function.
- $q_0 \in Q$ is the initial state.
- $F \subseteq Q$ is a set of accepting states (or final states). 

A finite automaton (also called a finite state machine) is a mathematical model for recognizing patterns within input. It is a type of abstract machine that has a finite number of states and transitions between those states based on input symbols. The automaton reads a string of symbols, one symbol at a time, and changes its state based on the current input symbol and the transition rules specified in its transition function. If the automaton reaches an accepting state, it is said to have accepted the input.

For every regular grammar can be obtained equivalent finite automaton.

## Objectives:

* Understand what a language is and what it needs to have in order to be considered a formal one.
* Create a local/remote repository for storing the project components, choose a proper programming language for task accomplishing. Choose a separate folder for keeping all reports.
* According to variant 11, get the grammar definition and do the following tasks:

  a) Implement a type/class for your grammar;

  b) Add one function that would generate 5 valid strings from the language expressed by your given grammar;

  c) Implement some functionality that would convert and object of type Grammar to one of type Finite Automaton;

  d) For the Finite Automaton, please add a method that checks if an input string can be obtained via the state transition from it;


## Implementation description


In my implementation I used two classes for grammar and finite automation. There are 2 additional generic classes for transitions and productions.


### Grammar class

The Grammar class is used for encapsulation of data and set of rules for generating strings in a language. It mimics a formal system for describing the structure of a particular language.

Attributes:

\+ (readonly) `nonTerminalSymbols`: string[] - set of non-terminal symbols;

\+ (readonly) `terminalSymbols`: string[] - set of terminal symbols;

\+ (readonly) `productions`: Production[] - finite set of productions of rules;

\+ (readonly) `startSymbol`: string - start symbol of a grammar;

\+ (readonly) `transitionMap`: Map<string, string[]>  - map which contains information simillar to productions set but in key-value form (`startState -> endState`).

Methods:

\+ **new Grammar**(`nonTerminalSymbols`: string[], `terminalSymbols`: string[], `productions`: Production[], `startSymbol`: string): Grammar

**`desc`** Constructs new Grammar.
Simultaneously generates the transition map for production rules.

\+ **genTransitionMap**(`productions`: Production[]): Map<string, string[]>

**`desc`** Creates a map with productions rules rewritten in key-pair format. Initial states are keys, values are final states. For example, in $S \to aB$ key is $S$, and value is $aB$. It is used for easier retrieval of transition states when building a new word.

\+ **genWord**(): string

**`desc`** Generates a new word based on current language. If the are more than one transitions with same initial state in production set, then one of them will be selected randomly.

\+ **toFiniteAutomation**(): FiniteAutomaton

**`desc`** Converts an object of type Grammar to one of type Finite Automaton simmilar to 5-tuple $(Q, \Sigma, \delta, q_0, F)$.

\+ **getNextState**(`initState`: string): string

**`desc`** Gets the next step of transition based on initial state. If there are rules of form $A \to aB \enspace | \enspace b \enspace | \enspace c \enspace | \enspace ...$, then the final state is selected randomly.


### FiniteAutomation class

Attributes:

\+ (readonly) `setOfStates`: string[] - set of possible FA states;

\+ (readonly) `alphabet`: string[] - alphabet of FA;

\+ (readonly) `transitions`: Transition[] - transition function, set of transition objects with start state, final state and transition label;

\+ (readonly) `initialState`: string - initial state of FA;

\+ (readonly) `finalState`: string  - final state of FA.

Methods:

\+ **new FiniteAutomation**(`setOfStates`: string[], `alphabet`: string[],`transitions`: Transition[], `intialState`: string, `finalState`: string): FiniteAutomation

**`desc`** Constructs new Grammar.
Simultaneously generates the transition map for production rules.

\+ **stringBelongToLanguage**(`word`: string): boolean

**`desc`** Verifies if string belongs to regular language on which FA relies on. Returns True if the given string belongs to the regular grammar defined by the automaton, and False otherwise.

The method implementation resides on the following algorithm:

1. Represent the regular grammar as a finite automaton.

2. Initialize the automaton in its starting state.

3. For each character in the string:
  a. Check if there is a transition from the current state to a next state for the current character.
  b. If there is a transition, move to the next state.
  c. If there is no transition, the string does not belong to the language defined by the grammar.
4. If the automaton reaches an accepting state, then the string belongs to the language defined by the grammar


### Transition class

Attributes:

\+ (readonly) `current`: string - initial state of FA;

\+ (readonly) `next`: string - alphabet of FA;

\+ (readonly) `transitionLabel`: string - label for particular FA transition

Methods:

\+ **new Transition**(`current`: string, `transitionLabel`: string,`next`: string): Transition

**`desc`** Creates new Transition object.


### Production class

Attributes:

\+ (readonly) `left`: string - initial state of FA;

\+ (readonly) `right`: string - alphabet of FA;

Methods:

\+ **new Production**(`left`: string, `right`: string): Production

**`desc`** Creates new Production object.


## Testing and debugging

For testing purposes were written a series of unit tests which are located in `test/` directory. In order to run all tests on your local machine, use `yarn test`. On the console you should see approximatelly the following output. The five strings represent valid words generated by previously implemented grammar.

![image](https://user-images.githubusercontent.com/92053176/218309453-a161c0eb-bfa2-42ca-94ff-d8f1a7b0db55.png)


## Conclusions

In this laboratory work I learned about regular grammars and finite automata, specifics for each of them, typical correlations and the way how regular grammars can be converted to finite automata and vice-versa. Also I implemented in code a simple model of grammar and finite automation, giving the possibility to understand in practice basic terminology and apply it in real use-cases.
Regular grammars and finite automata play significant role in our daily lives, even though we may not be aware of it. They are extensively used in compiler design, text editors, network security, NLP, data validation, etc.

To summarize, regular grammars and finite automata play a crucial role in many different areas of computer science and engineering, and their importance will continue to grow as technology becomes increasingly integrated into our daily lives.

## References

1. Compilers: Principles, Techniques, and Tools (2nd edition). Alfred V. Aho, Monica S. Lam, Ravi Sethi and Jeff Ullman. Publisher: Addison Wesley, 2007

2. COJUHARI, I., Formal Languages and Finite Automata, Guide for practical lessons. Publisher: Editura „Tehnica-UTM”, 2022 